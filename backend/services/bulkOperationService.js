const Issue = require('../models/Issue');\nconst activityLogService = require('./activityLogService');\nconst notificationService = require('./notificationService');\n\nclass BulkOperationService {\n  constructor() {\n    this.activeOperations = new Map();\n  }\n\n  // Create and execute a bulk operation\n  async createBulkOperation(operationData) {\n    try {\n      const {\n        operationType,\n        initiatedBy,\n        departmentId,\n        filters,\n        operationData: opData\n      } = operationData;\n\n      // Generate operation ID\n      const operationId = this.generateOperationId();\n      \n      // Validate operation\n      const validation = this.validateBulkOperation(operationType, opData);\n      if (!validation.isValid) {\n        return {\n          success: false,\n          message: 'Invalid operation data',\n          errors: validation.errors\n        };\n      }\n\n      // Get issues to operate on\n      const issues = await this.getIssuesForOperation(filters);\n      if (issues.length === 0) {\n        return {\n          success: false,\n          message: 'No issues found matching the criteria'\n        };\n      }\n\n      // Create operation record\n      const operation = {\n        id: operationId,\n        type: operationType,\n        initiatedBy,\n        departmentId,\n        status: 'in_progress',\n        totalIssues: issues.length,\n        processedIssues: 0,\n        successfulOperations: 0,\n        failedOperations: 0,\n        startTime: new Date(),\n        endTime: null,\n        results: [],\n        operationData: opData\n      };\n\n      this.activeOperations.set(operationId, operation);\n\n      // Execute operation asynchronously\n      this.executeBulkOperation(operationId, issues, operationType, opData, initiatedBy)\n        .catch(error => {\n          console.error('Bulk operation execution error:', error);\n          operation.status = 'failed';\n          operation.error = error.message;\n          operation.endTime = new Date();\n        });\n\n      return {\n        success: true,\n        operationId,\n        message: `Bulk operation started for ${issues.length} issues`,\n        totalIssues: issues.length\n      };\n\n    } catch (error) {\n      console.error('Error creating bulk operation:', error);\n      return {\n        success: false,\n        message: 'Failed to create bulk operation',\n        error: error.message\n      };\n    }\n  }\n\n  // Execute bulk operation on issues\n  async executeBulkOperation(operationId, issues, operationType, operationData, initiatedBy) {\n    const operation = this.activeOperations.get(operationId);\n    if (!operation) return;\n\n    try {\n      const batchSize = 10; // Process in batches\n      const batches = this.createBatches(issues, batchSize);\n      \n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        \n        for (const issue of batch) {\n          try {\n            const result = await this.executeOperationOnIssue(\n              issue,\n              operationType,\n              operationData,\n              initiatedBy\n            );\n            \n            operation.results.push({\n              issueId: issue._id,\n              success: result.success,\n              message: result.message,\n              error: result.error\n            });\n            \n            if (result.success) {\n              operation.successfulOperations++;\n            } else {\n              operation.failedOperations++;\n            }\n            \n          } catch (error) {\n            operation.results.push({\n              issueId: issue._id,\n              success: false,\n              error: error.message\n            });\n            operation.failedOperations++;\n          }\n          \n          operation.processedIssues++;\n        }\n        \n        // Small delay between batches\n        if (i < batches.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      }\n      \n      // Mark operation as completed\n      operation.status = 'completed';\n      operation.endTime = new Date();\n      \n      // Log bulk operation activity\n      await this.logBulkOperationActivity(operation, initiatedBy);\n      \n      // Send completion notification\n      await this.sendBulkOperationNotification(operation, initiatedBy);\n      \n    } catch (error) {\n      operation.status = 'failed';\n      operation.error = error.message;\n      operation.endTime = new Date();\n      throw error;\n    }\n  }\n\n  // Execute operation on a single issue\n  async executeOperationOnIssue(issue, operationType, operationData, initiatedBy) {\n    try {\n      switch (operationType) {\n        case 'status_update':\n          return await this.updateIssueStatus(issue, operationData, initiatedBy);\n        \n        case 'assign_issues':\n          return await this.assignIssue(issue, operationData, initiatedBy);\n        \n        case 'priority_update':\n          return await this.updateIssuePriority(issue, operationData, initiatedBy);\n        \n        case 'department_transfer':\n          return await this.transferIssueDepartment(issue, operationData, initiatedBy);\n        \n        default:\n          return {\n            success: false,\n            error: `Unknown operation type: ${operationType}`\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Update issue status\n  async updateIssueStatus(issue, operationData, initiatedBy) {\n    try {\n      const { status, reason } = operationData;\n      const previousStatus = issue.status;\n      \n      // Use the model method to update status with history\n      await issue.updateStatus(status, reason, initiatedBy);\n      \n      // Log activity\n      await activityLogService.logActivity({\n        issueId: issue._id,\n        actionType: 'status_changed',\n        performedBy: initiatedBy,\n        actionDetails: {\n          previousValue: previousStatus,\n          newValue: status,\n          reason,\n          metadata: {\n            source: 'bulk',\n            batchId: 'bulk_status_update'\n          }\n        },\n        visibility: 'internal',\n        severity: 'medium',\n        category: 'status'\n      });\n      \n      return {\n        success: true,\n        message: `Status updated from ${previousStatus} to ${status}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Assign issue\n  async assignIssue(issue, operationData, initiatedBy) {\n    try {\n      const { assignedTo, department } = operationData;\n      const previousAssignee = issue.assignedTo;\n      \n      issue.assignedTo = assignedTo;\n      issue.department = department;\n      issue.updatedAt = new Date();\n      await issue.save();\n      \n      // Log activity\n      await activityLogService.logActivity({\n        issueId: issue._id,\n        actionType: previousAssignee ? 'issue_reassigned' : 'issue_assigned',\n        performedBy: initiatedBy,\n        departmentId: department,\n        actionDetails: {\n          previousValue: previousAssignee,\n          newValue: assignedTo,\n          metadata: {\n            source: 'bulk',\n            batchId: 'bulk_assignment'\n          }\n        },\n        visibility: 'internal',\n        severity: 'medium',\n        category: 'assignment'\n      });\n      \n      return {\n        success: true,\n        message: `Issue assigned to ${assignedTo} in ${department}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Update issue priority\n  async updateIssuePriority(issue, operationData, initiatedBy) {\n    try {\n      const { priority } = operationData;\n      const previousPriority = issue.priority;\n      \n      issue.priority = priority;\n      issue.updatedAt = new Date();\n      await issue.save();\n      \n      // Log activity\n      await activityLogService.logActivity({\n        issueId: issue._id,\n        actionType: 'priority_changed',\n        performedBy: initiatedBy,\n        actionDetails: {\n          previousValue: previousPriority,\n          newValue: priority,\n          metadata: {\n            source: 'bulk',\n            batchId: 'bulk_priority_update'\n          }\n        },\n        visibility: 'internal',\n        severity: 'medium',\n        category: 'status'\n      });\n      \n      return {\n        success: true,\n        message: `Priority updated from ${previousPriority} to ${priority}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Transfer issue to different department\n  async transferIssueDepartment(issue, operationData, initiatedBy) {\n    try {\n      const { department } = operationData;\n      const previousDepartment = issue.department;\n      \n      issue.department = department;\n      issue.assignedTo = null; // Clear assignment when transferring departments\n      issue.updatedAt = new Date();\n      await issue.save();\n      \n      // Log activity\n      await activityLogService.logActivity({\n        issueId: issue._id,\n        actionType: 'issue_reassigned',\n        performedBy: initiatedBy,\n        departmentId: department,\n        actionDetails: {\n          previousValue: previousDepartment,\n          newValue: department,\n          notes: 'Department transfer via bulk operation',\n          metadata: {\n            source: 'bulk',\n            batchId: 'bulk_department_transfer'\n          }\n        },\n        visibility: 'internal',\n        severity: 'medium',\n        category: 'assignment'\n      });\n      \n      return {\n        success: true,\n        message: `Transferred from ${previousDepartment || 'unassigned'} to ${department}`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Get issues for operation based on filters\n  async getIssuesForOperation(filters) {\n    try {\n      const query = {};\n      \n      if (filters.issueIds && filters.issueIds.length > 0) {\n        query._id = { $in: filters.issueIds };\n      }\n      \n      if (filters.status) {\n        query.status = filters.status;\n      }\n      \n      if (filters.priority) {\n        query.priority = filters.priority;\n      }\n      \n      if (filters.category) {\n        query['category.primary'] = filters.category;\n      }\n      \n      if (filters.assignedTo) {\n        query.assignedTo = filters.assignedTo;\n      }\n      \n      if (filters.department) {\n        query.department = filters.department;\n      }\n      \n      if (filters.dateRange) {\n        query.createdAt = {};\n        if (filters.dateRange.start) {\n          query.createdAt.$gte = new Date(filters.dateRange.start);\n        }\n        if (filters.dateRange.end) {\n          query.createdAt.$lte = new Date(filters.dateRange.end);\n        }\n      }\n      \n      return await Issue.find(query).limit(1000); // Limit for safety\n    } catch (error) {\n      console.error('Error getting issues for operation:', error);\n      return [];\n    }\n  }\n\n  // Get operation status\n  async getOperationStatus(operationId) {\n    const operation = this.activeOperations.get(operationId);\n    if (!operation) {\n      return {\n        success: false,\n        message: 'Operation not found'\n      };\n    }\n    \n    return {\n      success: true,\n      operation: {\n        id: operation.id,\n        type: operation.type,\n        status: operation.status,\n        progress: {\n          total: operation.totalIssues,\n          processed: operation.processedIssues,\n          successful: operation.successfulOperations,\n          failed: operation.failedOperations,\n          percentage: operation.totalIssues > 0 ? \n            Math.round((operation.processedIssues / operation.totalIssues) * 100) : 0\n        },\n        startTime: operation.startTime,\n        endTime: operation.endTime,\n        error: operation.error\n      }\n    };\n  }\n\n  // Cancel operation\n  async cancelOperation(operationId) {\n    const operation = this.activeOperations.get(operationId);\n    if (!operation) {\n      return {\n        success: false,\n        message: 'Operation not found'\n      };\n    }\n    \n    if (operation.status === 'completed' || operation.status === 'failed') {\n      return {\n        success: false,\n        message: 'Operation already completed'\n      };\n    }\n    \n    operation.status = 'cancelled';\n    operation.endTime = new Date();\n    \n    return {\n      success: true,\n      message: 'Operation cancelled successfully'\n    };\n  }\n\n  // Validate bulk operation\n  validateBulkOperation(operationType, operationData) {\n    const errors = [];\n    \n    const validOperationTypes = [\n      'status_update',\n      'assign_issues',\n      'priority_update',\n      'department_transfer'\n    ];\n    \n    if (!validOperationTypes.includes(operationType)) {\n      errors.push(`Invalid operation type: ${operationType}`);\n    }\n    \n    switch (operationType) {\n      case 'status_update':\n        if (!operationData.status) {\n          errors.push('Status is required for status update operation');\n        }\n        if (!operationData.reason) {\n          errors.push('Reason is required for status update operation');\n        }\n        break;\n        \n      case 'assign_issues':\n        if (!operationData.assignedTo) {\n          errors.push('Assigned user is required for assignment operation');\n        }\n        if (!operationData.department) {\n          errors.push('Department is required for assignment operation');\n        }\n        break;\n        \n      case 'priority_update':\n        if (!operationData.priority) {\n          errors.push('Priority is required for priority update operation');\n        }\n        break;\n        \n      case 'department_transfer':\n        if (!operationData.department) {\n          errors.push('Department is required for department transfer operation');\n        }\n        break;\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  // Log bulk operation activity\n  async logBulkOperationActivity(operation, initiatedBy) {\n    try {\n      await activityLogService.logActivity({\n        issueId: null, // Bulk operations don't have a single issue ID\n        actionType: 'bulk_operation',\n        performedBy: initiatedBy,\n        departmentId: operation.departmentId,\n        actionDetails: {\n          operationType: operation.type,\n          totalIssues: operation.totalIssues,\n          successfulOperations: operation.successfulOperations,\n          failedOperations: operation.failedOperations,\n          metadata: {\n            source: 'bulk',\n            batchId: operation.id,\n            duration: operation.endTime - operation.startTime\n          }\n        },\n        visibility: 'admin_only',\n        severity: 'high',\n        category: 'system'\n      });\n    } catch (error) {\n      console.error('Error logging bulk operation activity:', error);\n    }\n  }\n\n  // Send bulk operation notification\n  async sendBulkOperationNotification(operation, initiatedBy) {\n    try {\n      await notificationService.createNotification({\n        userId: initiatedBy,\n        type: 'bulk_operation_completed',\n        title: 'Bulk Operation Completed',\n        message: `Bulk ${operation.type} completed: ${operation.successfulOperations}/${operation.totalIssues} successful`,\n        priority: operation.failedOperations > 0 ? 'high' : 'medium',\n        actionUrl: '/management/bulk-operations'\n      });\n    } catch (error) {\n      console.error('Error sending bulk operation notification:', error);\n    }\n  }\n\n  // Utility methods\n  generateOperationId() {\n    return `bulk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  createBatches(array, batchSize) {\n    const batches = [];\n    for (let i = 0; i < array.length; i += batchSize) {\n      batches.push(array.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  // Clean up completed operations (call periodically)\n  cleanupCompletedOperations(maxAge = 24 * 60 * 60 * 1000) { // 24 hours\n    const now = new Date();\n    for (const [operationId, operation] of this.activeOperations.entries()) {\n      if (operation.endTime && (now - operation.endTime) > maxAge) {\n        this.activeOperations.delete(operationId);\n      }\n    }\n  }\n}\n\nmodule.exports = new BulkOperationService();"