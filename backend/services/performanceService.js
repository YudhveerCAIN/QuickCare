const Issue = require('../models/Issue');\nconst ActivityLog = require('../models/ActivityLog');\n\nclass PerformanceService {\n  constructor() {\n    this.slaThresholds = {\n      'Critical': 4, // 4 hours\n      'High': 24,    // 24 hours\n      'Medium': 72,  // 72 hours\n      'Low': 168     // 168 hours (1 week)\n    };\n  }\n\n  // Calculate resolution time metrics\n  async calculateResolutionMetrics(options = {}) {\n    try {\n      const {\n        startDate,\n        endDate,\n        departmentId,\n        assignedTo,\n        category,\n        priority\n      } = options;\n\n      const matchStage = {\n        status: { $in: ['Resolved', 'Closed'] }\n      };\n\n      // Apply filters\n      if (startDate || endDate) {\n        matchStage.createdAt = {};\n        if (startDate) matchStage.createdAt.$gte = new Date(startDate);\n        if (endDate) matchStage.createdAt.$lte = new Date(endDate);\n      }\n\n      if (departmentId) matchStage.department = departmentId;\n      if (assignedTo) matchStage.assignedTo = assignedTo;\n      if (category) matchStage['category.primary'] = category;\n      if (priority) matchStage.priority = priority;\n\n      const metrics = await Issue.aggregate([\n        { $match: matchStage },\n        {\n          $addFields: {\n            resolutionTimeHours: {\n              $divide: [\n                { $subtract: ['$updatedAt', '$createdAt'] },\n                1000 * 60 * 60 // Convert to hours\n              ]\n            }\n          }\n        },\n        {\n          $group: {\n            _id: null,\n            totalIssues: { $sum: 1 },\n            averageResolutionTime: { $avg: '$resolutionTimeHours' },\n            medianResolutionTime: { $median: '$resolutionTimeHours' },\n            minResolutionTime: { $min: '$resolutionTimeHours' },\n            maxResolutionTime: { $max: '$resolutionTimeHours' },\n            resolutionTimes: { $push: '$resolutionTimeHours' }\n          }\n        }\n      ]);\n\n      return metrics[0] || {\n        totalIssues: 0,\n        averageResolutionTime: 0,\n        medianResolutionTime: 0,\n        minResolutionTime: 0,\n        maxResolutionTime: 0\n      };\n    } catch (error) {\n      console.error('Error calculating resolution metrics:', error);\n      throw error;\n    }\n  }\n\n  // Calculate SLA compliance metrics\n  async calculateSLAMetrics(options = {}) {\n    try {\n      const issues = await this.getIssuesForAnalysis(options);\n      const slaMetrics = {\n        total: issues.length,\n        withinSLA: 0,\n        breachedSLA: 0,\n        pending: 0,\n        byPriority: {}\n      };\n\n      issues.forEach(issue => {\n        const slaHours = this.slaThresholds[issue.priority] || this.slaThresholds['Medium'];\n        const ageHours = this.calculateIssueAgeHours(issue);\n        \n        if (!slaMetrics.byPriority[issue.priority]) {\n          slaMetrics.byPriority[issue.priority] = {\n            total: 0,\n            withinSLA: 0,\n            breachedSLA: 0,\n            pending: 0\n          };\n        }\n        \n        slaMetrics.byPriority[issue.priority].total++;\n        \n        if (issue.status === 'Resolved' || issue.status === 'Closed') {\n          if (ageHours <= slaHours) {\n            slaMetrics.withinSLA++;\n            slaMetrics.byPriority[issue.priority].withinSLA++;\n          } else {\n            slaMetrics.breachedSLA++;\n            slaMetrics.byPriority[issue.priority].breachedSLA++;\n          }\n        } else {\n          if (ageHours > slaHours) {\n            slaMetrics.breachedSLA++;\n            slaMetrics.byPriority[issue.priority].breachedSLA++;\n          } else {\n            slaMetrics.pending++;\n            slaMetrics.byPriority[issue.priority].pending++;\n          }\n        }\n      });\n\n      // Calculate compliance percentage\n      slaMetrics.complianceRate = slaMetrics.total > 0 ? \n        (slaMetrics.withinSLA / slaMetrics.total) * 100 : 0;\n\n      return slaMetrics;\n    } catch (error) {\n      console.error('Error calculating SLA metrics:', error);\n      throw error;\n    }\n  }\n\n  // Get department performance comparison\n  async getDepartmentPerformance(options = {}) {\n    try {\n      const departments = await Issue.aggregate([\n        {\n          $match: {\n            department: { $exists: true, $ne: null },\n            ...this.buildDateFilter(options)\n          }\n        },\n        {\n          $group: {\n            _id: '$department',\n            totalIssues: { $sum: 1 },\n            openIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'Open'] }, 1, 0] }\n            },\n            inProgressIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'In Progress'] }, 1, 0] }\n            },\n            resolvedIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'Resolved'] }, 1, 0] }\n            },\n            closedIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'Closed'] }, 1, 0] }\n            },\n            averageResolutionTime: {\n              $avg: {\n                $cond: [\n                  { $in: ['$status', ['Resolved', 'Closed']] },\n                  {\n                    $divide: [\n                      { $subtract: ['$updatedAt', '$createdAt'] },\n                      1000 * 60 * 60 // Convert to hours\n                    ]\n                  },\n                  null\n                ]\n              }\n            }\n          }\n        },\n        {\n          $addFields: {\n            resolutionRate: {\n              $cond: [\n                { $gt: ['$totalIssues', 0] },\n                {\n                  $multiply: [\n                    { $divide: [{ $add: ['$resolvedIssues', '$closedIssues'] }, '$totalIssues'] },\n                    100\n                  ]\n                },\n                0\n              ]\n            }\n          }\n        },\n        { $sort: { resolutionRate: -1 } }\n      ]);\n\n      return departments;\n    } catch (error) {\n      console.error('Error getting department performance:', error);\n      throw error;\n    }\n  }\n\n  // Get individual user performance\n  async getUserPerformance(userId, options = {}) {\n    try {\n      const userMetrics = await Issue.aggregate([\n        {\n          $match: {\n            assignedTo: userId,\n            ...this.buildDateFilter(options)\n          }\n        },\n        {\n          $group: {\n            _id: null,\n            totalAssigned: { $sum: 1 },\n            resolved: {\n              $sum: { $cond: [{ $eq: ['$status', 'Resolved'] }, 1, 0] }\n            },\n            closed: {\n              $sum: { $cond: [{ $eq: ['$status', 'Closed'] }, 1, 0] }\n            },\n            inProgress: {\n              $sum: { $cond: [{ $eq: ['$status', 'In Progress'] }, 1, 0] }\n            },\n            open: {\n              $sum: { $cond: [{ $eq: ['$status', 'Open'] }, 1, 0] }\n            },\n            averageResolutionTime: {\n              $avg: {\n                $cond: [\n                  { $in: ['$status', ['Resolved', 'Closed']] },\n                  {\n                    $divide: [\n                      { $subtract: ['$updatedAt', '$createdAt'] },\n                      1000 * 60 * 60\n                    ]\n                  },\n                  null\n                ]\n              }\n            }\n          }\n        }\n      ]);\n\n      const metrics = userMetrics[0] || {\n        totalAssigned: 0,\n        resolved: 0,\n        closed: 0,\n        inProgress: 0,\n        open: 0,\n        averageResolutionTime: 0\n      };\n\n      // Calculate additional metrics\n      metrics.completionRate = metrics.totalAssigned > 0 ? \n        ((metrics.resolved + metrics.closed) / metrics.totalAssigned) * 100 : 0;\n      \n      metrics.workload = metrics.open + metrics.inProgress;\n\n      return metrics;\n    } catch (error) {\n      console.error('Error getting user performance:', error);\n      throw error;\n    }\n  }\n\n  // Get performance trends over time\n  async getPerformanceTrends(options = {}) {\n    try {\n      const {\n        period = 'daily', // daily, weekly, monthly\n        startDate,\n        endDate,\n        departmentId\n      } = options;\n\n      let groupBy;\n      switch (period) {\n        case 'weekly':\n          groupBy = {\n            year: { $year: '$createdAt' },\n            week: { $week: '$createdAt' }\n          };\n          break;\n        case 'monthly':\n          groupBy = {\n            year: { $year: '$createdAt' },\n            month: { $month: '$createdAt' }\n          };\n          break;\n        default: // daily\n          groupBy = {\n            year: { $year: '$createdAt' },\n            month: { $month: '$createdAt' },\n            day: { $dayOfMonth: '$createdAt' }\n          };\n      }\n\n      const matchStage = this.buildDateFilter({ startDate, endDate });\n      if (departmentId) matchStage.department = departmentId;\n\n      const trends = await Issue.aggregate([\n        { $match: matchStage },\n        {\n          $group: {\n            _id: groupBy,\n            totalIssues: { $sum: 1 },\n            resolvedIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'Resolved'] }, 1, 0] }\n            },\n            closedIssues: {\n              $sum: { $cond: [{ $eq: ['$status', 'Closed'] }, 1, 0] }\n            },\n            averageResolutionTime: {\n              $avg: {\n                $cond: [\n                  { $in: ['$status', ['Resolved', 'Closed']] },\n                  {\n                    $divide: [\n                      { $subtract: ['$updatedAt', '$createdAt'] },\n                      1000 * 60 * 60\n                    ]\n                  },\n                  null\n                ]\n              }\n            }\n          }\n        },\n        { $sort: { '_id.year': 1, '_id.month': 1, '_id.day': 1, '_id.week': 1 } }\n      ]);\n\n      return trends.map(trend => ({\n        ...trend,\n        resolutionRate: trend.totalIssues > 0 ? \n          ((trend.resolvedIssues + trend.closedIssues) / trend.totalIssues) * 100 : 0\n      }));\n    } catch (error) {\n      console.error('Error getting performance trends:', error);\n      throw error;\n    }\n  }\n\n  // Get delayed issues (SLA breaches)\n  async getDelayedIssues(options = {}) {\n    try {\n      const issues = await this.getIssuesForAnalysis({\n        ...options,\n        excludeResolved: false\n      });\n\n      const delayedIssues = issues.filter(issue => {\n        const slaHours = this.slaThresholds[issue.priority] || this.slaThresholds['Medium'];\n        const ageHours = this.calculateIssueAgeHours(issue);\n        return ageHours > slaHours;\n      });\n\n      return delayedIssues.map(issue => ({\n        ...issue.toObject(),\n        ageHours: this.calculateIssueAgeHours(issue),\n        slaHours: this.slaThresholds[issue.priority] || this.slaThresholds['Medium'],\n        delayHours: this.calculateIssueAgeHours(issue) - (this.slaThresholds[issue.priority] || this.slaThresholds['Medium'])\n      }));\n    } catch (error) {\n      console.error('Error getting delayed issues:', error);\n      throw error;\n    }\n  }\n\n  // Calculate workload distribution\n  async getWorkloadDistribution(options = {}) {\n    try {\n      const workload = await Issue.aggregate([\n        {\n          $match: {\n            status: { $in: ['Open', 'In Progress'] },\n            assignedTo: { $exists: true, $ne: null },\n            ...this.buildDateFilter(options)\n          }\n        },\n        {\n          $group: {\n            _id: '$assignedTo',\n            totalIssues: { $sum: 1 },\n            criticalIssues: {\n              $sum: { $cond: [{ $eq: ['$priority', 'Critical'] }, 1, 0] }\n            },\n            highIssues: {\n              $sum: { $cond: [{ $eq: ['$priority', 'High'] }, 1, 0] }\n            },\n            mediumIssues: {\n              $sum: { $cond: [{ $eq: ['$priority', 'Medium'] }, 1, 0] }\n            },\n            lowIssues: {\n              $sum: { $cond: [{ $eq: ['$priority', 'Low'] }, 1, 0] }\n            },\n            department: { $first: '$department' }\n          }\n        },\n        {\n          $lookup: {\n            from: 'users',\n            localField: '_id',\n            foreignField: '_id',\n            as: 'userInfo'\n          }\n        },\n        {\n          $addFields: {\n            workloadScore: {\n              $add: [\n                { $multiply: ['$criticalIssues', 4] },\n                { $multiply: ['$highIssues', 3] },\n                { $multiply: ['$mediumIssues', 2] },\n                '$lowIssues'\n              ]\n            }\n          }\n        },\n        { $sort: { workloadScore: -1 } }\n      ]);\n\n      return workload;\n    } catch (error) {\n      console.error('Error getting workload distribution:', error);\n      throw error;\n    }\n  }\n\n  // Helper methods\n  buildDateFilter(options) {\n    const filter = {};\n    if (options.startDate || options.endDate) {\n      filter.createdAt = {};\n      if (options.startDate) filter.createdAt.$gte = new Date(options.startDate);\n      if (options.endDate) filter.createdAt.$lte = new Date(options.endDate);\n    }\n    return filter;\n  }\n\n  async getIssuesForAnalysis(options = {}) {\n    const query = {};\n    \n    if (!options.excludeResolved) {\n      // Include all issues\n    } else {\n      query.status = { $nin: ['Resolved', 'Closed'] };\n    }\n    \n    if (options.departmentId) query.department = options.departmentId;\n    if (options.assignedTo) query.assignedTo = options.assignedTo;\n    if (options.category) query['category.primary'] = options.category;\n    if (options.priority) query.priority = options.priority;\n    \n    Object.assign(query, this.buildDateFilter(options));\n    \n    return await Issue.find(query)\n      .populate('assignedTo', 'firstName lastName email')\n      .populate('submittedBy', 'firstName lastName email');\n  }\n\n  calculateIssueAgeHours(issue) {\n    const now = new Date();\n    const created = new Date(issue.createdAt);\n    return (now - created) / (1000 * 60 * 60); // Convert to hours\n  }\n\n  // Generate comprehensive performance report\n  async generatePerformanceReport(options = {}) {\n    try {\n      const [\n        resolutionMetrics,\n        slaMetrics,\n        departmentPerformance,\n        trends,\n        delayedIssues,\n        workloadDistribution\n      ] = await Promise.all([\n        this.calculateResolutionMetrics(options),\n        this.calculateSLAMetrics(options),\n        this.getDepartmentPerformance(options),\n        this.getPerformanceTrends(options),\n        this.getDelayedIssues(options),\n        this.getWorkloadDistribution(options)\n      ]);\n\n      return {\n        generatedAt: new Date(),\n        period: {\n          startDate: options.startDate,\n          endDate: options.endDate\n        },\n        resolutionMetrics,\n        slaMetrics,\n        departmentPerformance,\n        trends,\n        delayedIssues: delayedIssues.slice(0, 10), // Top 10 most delayed\n        workloadDistribution,\n        summary: {\n          totalIssues: resolutionMetrics.totalIssues,\n          averageResolutionTime: Math.round(resolutionMetrics.averageResolutionTime * 100) / 100,\n          slaComplianceRate: Math.round(slaMetrics.complianceRate * 100) / 100,\n          delayedIssuesCount: delayedIssues.length,\n          topPerformingDepartment: departmentPerformance[0]?.name || 'N/A'\n        }\n      };\n    } catch (error) {\n      console.error('Error generating performance report:', error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = new PerformanceService();"